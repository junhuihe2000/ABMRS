# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name ClassBinEBARS
#' @title bivariate extended Bayesian adaptive regression spline
#' @description a class of [binebars()]
#'
#' @field new constructor, see `binebars`
#' @field rjmcmc reversible jump MCMC, a wrapper is `mcmc`
#' @field predict predict by surface spline regression with EBARS
#' @field knots return estimated knots
#' @field samples return posterior samples
NULL

#' @name ClassEBARS
#' @title extended Bayesian adaptive regression univariate spline
#' @description a cpp class
#'
#' @field new constructor, see `ebars`
#' @field rjmcmc run reversible jump MCMC algorithm
#' @field predict predict posterior response values for new data
#' @field knots get posterior samples of knots
#' @field coefs get posterior samples of regression coefficients
#' @field resids get posterior samples of residual standard deviations
NULL

#' @name ClassMEBARS
#' @title extended Bayesian adaptive regression multivariate spline
#' @description a cpp class
#'
#' @field new constructor, see `mebars`
#' @field rjmcmc run reversible jump MCMC algorithm
#' @field predict predict posterior response values for new data
#' @field knots get posterior samples of knots
#' @field coefs get posterior samples of regression coefficients
#' @field resids get posterior samples of residual standard deviations
NULL

#' @name ClassTriEBARS
#' @title trivariate extended Bayesian adaptive regression spline
#' @description a class of [triebars()]
#'
#' @field new constructor, see `triebars`
#' @field rjmcmc reversible jump MCMC, a wrapper is `mcmc`
#' @field predict predict by trivariate spline regression with EBARS
#' @field knots return estimated knots
#' @field samples return posterior samples
NULL

#' create a univariate B-spline basis matrix
#' @param x a numeric vector of predictor values.
#' @param xi a numeric vector, indicates the knots.
#' @param degree int, the degree of polynomial, default value is `3`.
#' @param intercept bool, whether the intercept is included in the basis, default value is `FALSE`.
#'
#' @returns a B-spline basis matrix.
#' @export
spline <- function(x, xi, degree, intercept) {
    .Call(`_EBARS_spline`, x, xi, degree, intercept)
}

#' create a general tensor product spline basis matrix for arbitrary dimensions
#' @param x a numeric matrix, (m,d), each row indicates a predictor value.
#' @param xis a list of numeric vectors, each element contains knots for one dimension.
#' @param degrees an integer vector, degrees for each dimension, default is `c(3,3,...)`.
#' @param intercepts a logical vector, whether intercepts are included for each dimension, default is `c(FALSE,FALSE,...)`.
#'
#' @returns a tensor product B-spline basis matrix.
#'
#' @export
#' @examples
#' # 2D example
#' x <- matrix(runif(100), ncol=2)
#' xis <- list(c(0.3, 0.6), c(0.4, 0.5))
#' B <- tensor_spline(x, xis, c(3,3), c(FALSE,FALSE))
#' 
#' # 3D example
#' x <- matrix(runif(150), ncol=3)
#' xis <- list(c(0.2, 0.5), c(0.3, 0.7), c(0.4))
#' B <- tensor_spline(x, xis, c(3,3,3), c(TRUE,TRUE,TRUE))
tensor_spline <- function(x, xis, degrees, intercepts) {
    .Call(`_EBARS_tensor_spline`, x, xis, degrees, intercepts)
}

#' create a bivariate tensor product spline basis matrix
#' @param x a numeric matrix, (m,2), each row indicates a predictor value (x_1,x_2).
#' @param xi_1 a numeric vector, indicates `k_1` knots in x_1.
#' @param xi_2 a numeric vector, indicates `k_2` knots in x_2
#' @param degree_1 int, the degree of polynomial in x_1, default value is `3`.
#' @param degree_2 int, the degree of polynomial in x_2, default value is `3`.
#' @param intercept_1 bool, whether the intercept is included in the basis in x_1,
#' default value is `FALSE`.
#' @param intercept_2 bool, whether the intercept is included in the basis in x_2,
#' default value is `FALSE`.
#'
#' @returns a bivariate tensor product B-spline basis matrix.
#'
#' @export
bi_tensor_spline <- function(x, xi_1, xi_2, degree_1 = 3L, degree_2 = 3L, intercept_1 = FALSE, intercept_2 = FALSE) {
    .Call(`_EBARS_bi_tensor_spline`, x, xi_1, xi_2, degree_1, degree_2, intercept_1, intercept_2)
}

#' create a trivariate tensor product spline basis matrix
#' @param x a numeric matrix, (m,3), each row indicates a predictor value (x_1,x_2,x_3).
#' @param xi_1 a numeric vector, indicates `k_1` knots in x_1.
#' @param xi_2 a numeric vector, indicates `k_2` knots in x_2
#' @param xi_3 a numeric vector, indicates `k_3` knots in x_3
#' @param degree_1 int, the degree of polynomial in x_1, default value is `3`.
#' @param degree_2 int, the degree of polynomial in x_2, default value is `3`.
#' @param degree_3 int, the degree of polynomial in x_3, default value is `3`.
#' @param intercept_1 bool, whether the intercept is included in the basis in x_1,
#' default value is `FALSE`.
#' @param intercept_2 bool, whether the intercept is included in the basis in x_2,
#' default value is `FALSE`.
#' @param intercept_3 bool, whether the intercept is included in the basis in x_3,
#' default value is `FALSE`.
#'
#' @returns a trivariate tensor product B-spline basis matrix.
#'
#' @export
tri_tensor_spline <- function(x, xi_1, xi_2, xi_3, degree_1 = 3L, degree_2 = 3L, degree_3 = 3L, intercept_1 = FALSE, intercept_2 = FALSE, intercept_3 = FALSE) {
    .Call(`_EBARS_tri_tensor_spline`, x, xi_1, xi_2, xi_3, degree_1, degree_2, degree_3, intercept_1, intercept_2, intercept_3)
}

