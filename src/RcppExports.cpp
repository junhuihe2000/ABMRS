// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppEigen.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// tensor_spline
Eigen::MatrixXd tensor_spline(const Eigen::MatrixXd& x, const Eigen::VectorXd& xi_1, const Eigen::VectorXd& xi_2, int degree_1, int degree_2, bool intercept_1, bool intercept_2);
RcppExport SEXP _EBARS_tensor_spline(SEXP xSEXP, SEXP xi_1SEXP, SEXP xi_2SEXP, SEXP degree_1SEXP, SEXP degree_2SEXP, SEXP intercept_1SEXP, SEXP intercept_2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::MatrixXd& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type xi_1(xi_1SEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type xi_2(xi_2SEXP);
    Rcpp::traits::input_parameter< int >::type degree_1(degree_1SEXP);
    Rcpp::traits::input_parameter< int >::type degree_2(degree_2SEXP);
    Rcpp::traits::input_parameter< bool >::type intercept_1(intercept_1SEXP);
    Rcpp::traits::input_parameter< bool >::type intercept_2(intercept_2SEXP);
    rcpp_result_gen = Rcpp::wrap(tensor_spline(x, xi_1, xi_2, degree_1, degree_2, intercept_1, intercept_2));
    return rcpp_result_gen;
END_RCPP
}
// tri_tensor_spline
Eigen::MatrixXd tri_tensor_spline(const Eigen::MatrixXd& x, const Eigen::VectorXd& xi_1, const Eigen::VectorXd& xi_2, const Eigen::VectorXd& xi_3, int degree_1, int degree_2, int degree_3, bool intercept_1, bool intercept_2, bool intercept_3);
RcppExport SEXP _EBARS_tri_tensor_spline(SEXP xSEXP, SEXP xi_1SEXP, SEXP xi_2SEXP, SEXP xi_3SEXP, SEXP degree_1SEXP, SEXP degree_2SEXP, SEXP degree_3SEXP, SEXP intercept_1SEXP, SEXP intercept_2SEXP, SEXP intercept_3SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::MatrixXd& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type xi_1(xi_1SEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type xi_2(xi_2SEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type xi_3(xi_3SEXP);
    Rcpp::traits::input_parameter< int >::type degree_1(degree_1SEXP);
    Rcpp::traits::input_parameter< int >::type degree_2(degree_2SEXP);
    Rcpp::traits::input_parameter< int >::type degree_3(degree_3SEXP);
    Rcpp::traits::input_parameter< bool >::type intercept_1(intercept_1SEXP);
    Rcpp::traits::input_parameter< bool >::type intercept_2(intercept_2SEXP);
    Rcpp::traits::input_parameter< bool >::type intercept_3(intercept_3SEXP);
    rcpp_result_gen = Rcpp::wrap(tri_tensor_spline(x, xi_1, xi_2, xi_3, degree_1, degree_2, degree_3, intercept_1, intercept_2, intercept_3));
    return rcpp_result_gen;
END_RCPP
}

RcppExport SEXP _rcpp_module_boot_class_BinEBARS();
RcppExport SEXP _rcpp_module_boot_class_EBARS();
RcppExport SEXP _rcpp_module_boot_class_TriEBARS();

static const R_CallMethodDef CallEntries[] = {
    {"_EBARS_tensor_spline", (DL_FUNC) &_EBARS_tensor_spline, 7},
    {"_EBARS_tri_tensor_spline", (DL_FUNC) &_EBARS_tri_tensor_spline, 10},
    {"_rcpp_module_boot_class_BinEBARS", (DL_FUNC) &_rcpp_module_boot_class_BinEBARS, 0},
    {"_rcpp_module_boot_class_EBARS", (DL_FUNC) &_rcpp_module_boot_class_EBARS, 0},
    {"_rcpp_module_boot_class_TriEBARS", (DL_FUNC) &_rcpp_module_boot_class_TriEBARS, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_EBARS(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
